function [w, b] = SSVR(A, y, w0, b0, C, ins)%# Smooth Support Vector Machine for epsilon-insensitive Regression  #%# It handles only the univariate-response SSVR                      #  %#-------------------------------------------------------------------#%# Inputs                                                            #%#   A: training inputs, size [n p].                                 #%#   y: response, can be k-variate response, size [n k]              #%#   [w0; b0]: Initial values for regression coefficients            #%#   C: weight parameter                                             #%#                                                                   #%# Outputs                                                           #%#  w: regression coefficients, [p k] matrix.                        #%#  b: bias vector, size [1 k].                                      #%#-------------------------------------------------------------------#%# References:                                                       #%# Yuh-Jye Lee, Wen-Feng Hsieh and Chien-Ming Huang (2005)           #%#   epsilon-SSVR: a smooth support vector machine for               #%#   epsilon-insensitive regression.                                 #%#   IEEE Trans. on Knowledge and Data Engineering, 17: 678-685.     #%#   http://dmlab1.csie.ntust.edu.tw                                 #%# modified by S.Y. Huang based on original authors' SSVR_M code     #                                                                   #%#####################################################################[row_A column_A]=size(A);A = [A ones(row_A,1)];% A=[A e];column_A=column_A+1;w0=[w0;b0];flag = 1;T = speye(column_A)/C;counter = 0;while flag > 1E-4 % threshold for norm(z)     counter = counter+1;     [h minus] = insen(y-A*w0,ins,1);          h (minus,:) = -h(minus,:);     gradient = w0/C-A'*h;          if (gradient'*gradient/column_A> 1E-5)                                            t = sign(h);                 lh = (t ~= 0);                 a = A(lh,:);        hessian =T + a'*a;             z = hessian\(-gradient);  % descent direction        stepsize = armijo(h, A, y, w0, C, ins, z);%input h for armijo step        z = stepsize*z;                w0 = w0 + z;                       flag = norm(z);     else           flag = 0;     end          if (counter ==150)         break     end end  w=w0(1:column_A-1); b=w0(column_A);%=====================================================================function stepsize = armijo(r ,A, y, w0, C, ins, descent)stepsize = 1;flag = 1;[row_A column_A]=size(A);            obj1 = w0'*w0/C + r'*r; while flag >= 1    w1= w0 + stepsize*descent(1:column_A);    h = insen(y-A*w1,ins,2);    obj2 = w1'*w1/C+  h'*h;    if obj2 >= obj1        stepsize = stepsize/2;        if stepsize < 1E-5            break;        end    else        break;    endend%=====================================================================function [E , minus] = insen(V, d, Type)%  input V is a column vector %        d is a number (insenstive number)%        Type = 1, plus=find(V == d), minus=find(V == -d)%%%  output E is a column vector% % if Vi <= d  and Vi >= 0 then Ei=0% if Vi >= -d and Vi <  0 then Ei=0% if Vi > d  and Vi > 0 then Ei = Vi - d% if Vi < -d and Vi < 0 then Ei = Vi + dif (Type == 1)    minus = find(V < -d);endE = max((abs(V)-d),0);