function [w, b] = SSVM(A, B, C, w0, b0)%#####################################################################%# Smooth Support Vector Machine                                     #%# Authors: Yuh-Jye Lee and O. L. Mangasarian                        #%# Programers: Yuh-Jye Lee and Chien-Ming Huang                      #%# Web Site: http://dmlab1.csie.ntust.edu.tw/downloads/              #%# modified by Su-Yun Huang                                          #%#                                                                   #%# Please send comments and suggestions to                           #%# "yuh-jye@mail.ntust.edu.tw"                                       #%#                                                                   #%# Inputs                                                            #%#   A: Represent A+ data                                            #%#   B: Represent A- data                                            #%#   [w0; b0]: Initial point                                         #%#   C: weight parameter                                             #%#                                                                   #%# Outputs                                                           #%#   w: the normal vector of the classifier                          #%#   b: the threshold                                                #%#                                                                   #%# Note:                                                             #%#   1. In order to handle a massive dataset this code               #%#      takes the advantage of sparsity of the Hessian               #%#      matrix.                                                      #%#                                                                   #%#   2. We use the limit values of the sigmoid function              #%#      and p-function as the smoothing parameter \alpha             #%#      goes to infinity when we compute the Hessian                 #%#      matrix and the gradient of objective function.               #%#                                                                   #%#   3. Decrease C when the classifier is overfitting                #%#      the training data.                                           #%#                                                                   #%#   4. The form of classifier is w'x-b (x is a test point).         #%#                                                                   #%#####################################################################% [A;-B] is the "DA" in SSVM paperA=[A -ones(size(A,1),1); -B ones(size(B,1),1)]; [m n]=size(A);e = ones(m, 1); w0=[w0;b0];flag = 1;counter =0;while flag > 1E-5       counter = counter+1;  % Find a search direction!  y=A*w0; d=e-y;    Ih = find(d > 0);  % We only consider the nonzero part  if(isempty(Ih))    % Sometimes, the length of Ih will be zero.       break;         % In this condition, we can finish this job directly.  end;     hessian= speye(n)/C + A(Ih,:)'*A(Ih,:);  gradz=w0/C - A(Ih,:)'*d(Ih); % gradient    clear Ih d y    if  (gradz'*gradz/n > 1E-5) % Check the First Order Opt. condition      z = -hessian\gradz;  % z is the Newton direction                  clear hessian             % stepsize = 1; % The default stepsize is 1      obj1 =  objf(A, w0, C);            w2 = w0 + z ;       obj2 = objf(A, w2, C);                  if (obj1 - obj2) <= 1E-8          % Use the Armijo's rule                     gap = z'*gradz; % Compute the gap                 % Find the step size & Update to the new point          stepsize = armijo(A, w0, C, z, gap, obj1);          w0 = w0 + stepsize*z;                else          % Use the Newton method          w0 = w2;        end       flag = norm(z);   else            break;  end;  if (counter==150)      break;  endend;w = w0(1:end-1); b = w0(end);%====================================================================%function stepsize = armijo(A, w, C, z, gap, obj1)% Input%   w1, b1: Current point%   C: weight parameter %   gap: defined in ssvm code%   obj1: the object function value of current point %   diff: the difference of objective function values at current and next%         pointsdiff=0;temp=0.5; % we start to test with setpsize=0.5count = 1;while diff  < -0.05*temp*gap    temp = 0.5*temp;    w2 = w + temp*z;     obj2 = objf(A, w2, C);    diff = obj1 - obj2;          count = count+1;    if (count>20)        break;    endend;stepsize = temp;%====================================================================%function value = objf(A, w, C)% Evaluate the function valuetemp=ones(size(A,1),1)-A*w;  v = max(temp,0);value = 0.5*(v'*v + w'*w/C);